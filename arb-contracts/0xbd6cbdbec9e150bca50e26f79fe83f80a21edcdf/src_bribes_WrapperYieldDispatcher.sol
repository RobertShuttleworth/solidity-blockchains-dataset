// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.26;

import {IERC20} from "./lib_openzeppelin-contracts-upgradeable_lib_openzeppelin-contracts_contracts_token_ERC20_IERC20.sol";
import {SafeERC20} from "./lib_openzeppelin-contracts-upgradeable_lib_openzeppelin-contracts_contracts_token_ERC20_utils_SafeERC20.sol";

import {IVault, IERC20 as BALANCER_IERC20} from './lib_balancer-v2-monorepo_pkg_interfaces_contracts_vault_IVault.sol';
import {IManagedPool} from './lib_balancer-v2-monorepo_pkg_interfaces_contracts_pool-utils_IManagedPool.sol';

import {ComposablePoolLib} from "./src_libraries_ComposablePoolLib.sol";
import {IWrapper} from "./src_interfaces_IWrapper.sol";
import {IBribe} from './src_interfaces_IBribe.sol';
import {VoterV4} from "./src_VoterV4.sol";

import {removeSelector} from "./lib_vulcan_src_utils.sol";

/// @title WrapperYieldDispatcher
/// @author Cadabra Finance
/// @notice The purpose of the contract is to route the yield generated by the wrappers to the internal bribes. 
/// This approach  allows us to configure all wrappers to trust a single instance of the YieldDispatcher for claims,
/// while also making the yield distribution process permissionless.
contract WrapperYieldDispatcher {
    using SafeERC20 for IERC20;

    error _ClaimAmountsResult(address[] rewardTokens, uint[] rewardsClaimed);
    error UnexpectedErrorSignature(bytes revertData);
    error Unexpected();

    IVault  immutable VAULT;
    VoterV4 immutable VOTER;

    constructor(IVault _vault, VoterV4 _voter) {
        VAULT = _vault;
        VOTER = _voter;
    }

    function dispatch(address pool) external {
        (BALANCER_IERC20[] memory tokens, ,) = VAULT.getPoolTokens(IManagedPool(pool).getPoolId());
        IERC20[] memory wrappers = ComposablePoolLib.dropBptFromTokens(tokens); // mutates wrappers variable

        for (uint i = 0; i < wrappers.length; i++) {
            IWrapper wrapper = IWrapper(address(wrappers[i]));
            IBribe internalBribe = IBribe(VOTER.internalBribes(address(wrapper)));
            if (!internalBribe.canNotifyReward()) {
                continue;
            }
            address[] memory rewardTokens = wrapper.rewardTokens();
            // uint256[] memory amounts = new uint[](rewardTokens.length);

            // for (uint j = 0; j < rewardTokens.length; j++) {
            //     amounts[j] = IERC20(rewardTokens[j]).balanceOf(address(this));
            // }

            wrapper.claim(address(this));

            for (uint j = 0; j < rewardTokens.length; j++) {
                // amounts[j] = IERC20(rewardTokens[j]).balanceOf(address(this)) - amounts[j];
                uint amount = IERC20(rewardTokens[j]).balanceOf(address(this));
                if (amount > 0) {
                    IERC20(rewardTokens[j]).forceApprove(address(internalBribe), amount);
                    internalBribe.notifyRewardAmount(rewardTokens[j], amount);
                }
            }
        }
    }

    function pendingRewards(
        IWrapper wrapper
    ) external returns (address[] memory tokens, uint[] memory amounts) {
        try this._claimAndRevert(wrapper) {
        } catch (bytes memory data) {
            if(bytes4(data) != _ClaimAmountsResult.selector) {
                revert UnexpectedErrorSignature(data);
            }
            return abi.decode(removeSelector(data), (address[], uint[]));
        }
        revert Unexpected();
    }

    function _claimAndRevert(IWrapper wrapper) external {
        address[] memory rewardTokens = wrapper.rewardTokens();
        uint[]  memory rewardsClaimed = new uint[](rewardTokens.length);

        for (uint i = 0; i < rewardTokens.length; ++i) {
            // will be calculated later
            rewardsClaimed[i] = IERC20(rewardTokens[i]).balanceOf(address(this));
        }

        wrapper.claim(address(this));

        for (uint i = 0; i < rewardTokens.length; ++i) {
            uint rewardBalance = IERC20(rewardTokens[i]).balanceOf(address(this));
            rewardsClaimed[i] = rewardBalance - rewardsClaimed[i];
        }

        revert _ClaimAmountsResult(rewardTokens, rewardsClaimed);
    }

    function vault() external view returns(IVault) {
        return VAULT;
    }

    function voter() external view returns(VoterV4) {
        return VOTER;
    }
}