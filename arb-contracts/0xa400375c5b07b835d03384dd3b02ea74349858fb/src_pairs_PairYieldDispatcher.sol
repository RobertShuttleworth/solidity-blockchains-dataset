// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.26;

import {IERC20} from "./lib_openzeppelin-contracts-upgradeable_lib_openzeppelin-contracts_contracts_token_ERC20_IERC20.sol";
import {SafeERC20} from "./lib_openzeppelin-contracts-upgradeable_lib_openzeppelin-contracts_contracts_token_ERC20_utils_SafeERC20.sol";

import {IVault, IERC20 as BALANCER_IERC20} from './lib_balancer-v2-monorepo_pkg_interfaces_contracts_vault_IVault.sol';
import {IManagedPool} from './lib_balancer-v2-monorepo_pkg_interfaces_contracts_pool-utils_IManagedPool.sol';

import {IWrapper} from "./src_interfaces_IWrapper.sol";
import {Bribe, Bribe_NoVotes} from './src_bribes_Bribe.sol';
import {VoterV4} from "./src_VoterV4.sol";
import {UniswapV3FullRangePair} from "./src_pairs_UniswapV3FullRangePair.sol";

/// @title PairYieldDispatcher
/// @author Cadabra Finance
/// @notice The purpose of the contract is to route the yield generated by the full-range pair to the internal bribes. 
/// This approach  allows us to configure all pairs to trust a single instance of the PairYieldDispatcher for claims,
/// while also making the yield distribution process permissionless.
contract PairYieldDispatcher {
    using SafeERC20 for IERC20;
    
    VoterV4 immutable VOTER;

    constructor(VoterV4 _voter) {
        VOTER = _voter;
    }

    function dispatch(UniswapV3FullRangePair pair) external {
        Bribe internalBribe = Bribe(VOTER.internalBribes(address(pair)));
        if (!internalBribe.canNotifyReward()) {
            return;
        }

        (uint a0, uint a1) = pair.collect(address(this));

        IERC20(pair.token0()).forceApprove(address(internalBribe), a0);
        internalBribe.notifyRewardAmount(pair.token0(), a0);

        IERC20(pair.token1()).forceApprove(address(internalBribe), a1);
        internalBribe.notifyRewardAmount(pair.token1(), a1);
    }

    function voter() external view returns(VoterV4) {
        return VOTER;
    }
}